	After the extensive research we did on Elm and Tetris for part 2 of this project, we set to work on implementing our designs in Elm. We were able to put together our project relatively quickly, as a result of our work on part 2.

	We divided the coding on this project into 2 parts, game logic and graphics. At first, we developed these systems largely independent of one another, until both elements reached a point where integration was necessary for them to progress. In both the logic and the graphical components, we first implemented the necessary structures for creating, drawing and manipulating basic board layouts. Then we wrote the code for creating, drawing and then manipulating Tetrominos. First we had to define a data structure to hold Tetromino data. We settled on a record with the shape of Tetromino, the current position of all of its blocks and its current orientation. This allowed us to manipulate Tetrominos easily given the mutable nature of records. 

	Rotation of the Tetrominos proved to be the hardest part; our function for this ended up being quite long since there was no easy way to predict the rotations of the Tetrominos, and we had to hard code all of the transformations. Though we had to debug rotations a lot, we eventually got it working well. Transformations were entirely based on Tetris's standardized Super Rotation System (SRS) that defines a default (usually "horizontal") position, along with three other rotations each at succesive 90* offsets from one another. 
	
	Collision was also a little tricky. We ended up just checking "slices" of the board using basic list functions within a two-dimensional array. Library List functions were prioritized due their optimization, but we ocassionally needed to use custom ones (using tail recursion, of course) to keep track of the number of lines cleared to update the score. Whenever a "setTetromino" event is triggered, our code checks all slices, removes full ones, and pushes remaining ones down. 
  
	In this project, we adapted some of the MVC funcitonality we learned in this course to support a pretty-close replice of Tetris. Along the way, we learned useful libraries for representing data structures (namely, Collage, Array, and Graphics), accepting input (Keyboard), and modifying a stateful protocol on the basis of time and events (Time and Random) within dynamic Html pages. Moving forward, we can use the knowledge and experience gained developing this software to emulate more games or produce other interactive, fun web-pages. 
 
